===[START: {xd-chrome-cli.js}]===
/**
 * @fileoverview CLI interface for xd-chrome. Maps shell commands to tool executions.
 * @module xd-chrome-cli
 */

import { createAgentContext, DEFAULT_CONFIG } from './xd-chrome-core.js'
import { createTools } from './xd-chrome-tools.js'
import { parseArgv, parseList, safeJsonParse, toBoolean, truncate, normalizeUrl } from './xd-chrome-helpers.js'

/** @type {Record<string, string>} CLI command → tool name mapping */
const COMMAND_TO_TOOL = {
 init: 'init',
 close: 'close',
 navigate: 'navigate',
 snapshot: 'snapshot',
 click: 'click',
 fill: 'fill',
 'open-link': 'openLink',
 scroll: 'scroll',
 tab: 'switchToTab',
 proxy: 'proxyControl',
 adblock: 'adblockControl',
 fingerprint: 'generateFingerprint',
 stealth: 'detectStealthIssues',
 behavior: 'rotateBehaviorProfile',
 wait: 'wait',
 extract: 'extractContent',
 source: 'getSource',
 eval: 'evaluate_script',
 key: 'press_key',
 dialog: 'handle_dialog',
 save: 'saveResult',
 read: 'readResult',
 done: 'done'
}

/** ANSI color helpers for terminal output */
const Colors = {
 info: '\x1b[36m', success: '\x1b[32m', error: '\x1b[31m',
 dim: '\x1b[2m', reset: '\x1b[0m', warn: '\x1b[33m'
}

const HELP_TEXT = `${Colors.info}Usage:${Colors.reset}
  node xd-chrome.js <command> [options]

${Colors.info}Commands:${Colors.reset}
  init                                   Initialize browser
  close                                  Close browser
  navigate --url <https://...>           Navigate to URL
  snapshot [--verbose]                   Take DOM snapshot
  click --uid <el_0>                     Click element
  fill --uid <el_0> --text "value"       Fill input
  open-link --uid <el_0>                 Open link by href
  scroll [--direction down|up|bottom]    Scroll page
  tab --target <0|url-fragment>          Switch tab
  proxy <status|rotate>                  Proxy control
  adblock <status|enable|disable|...>    Adblock control
  fingerprint [--config '{}']            Generate fingerprint
  stealth                                Detect stealth issues
  behavior                               Rotate behavior profile
  wait --ms 1200                         Wait
  extract [--selector "article"]         Extract page text
  source [--includeDoctype]              Get HTML source
  eval --script "return document.title"  Execute JS
  key --key Enter                        Press key
  dialog --action accept                 Handle dialog
  save --filename out.md --content "..."  Save result
  read --filename out.md                 Read result
  done --reason "Task complete"          Signal completion
`

/**
 * Build a unique signature for a tool decision (for dedup/logging).
 * @param {{tool: string, params: object}} decision
 * @returns {string}
 */
const decisionSignature = (decision) => {
 const tool = decision?.tool || ''
 const params = decision?.params || {}
 switch (tool) {
  case 'navigate': return `url=${normalizeUrl(params.url)}`
  case 'click': case 'openLink': case 'fill': return `uid=${truncate(params.uid, 40)}`
  case 'press_key': return `key=${truncate(params.key, 40)}`
  case 'scroll': return `direction=${truncate(params.direction, 20)}`
  case 'switchToTab': return `target=${truncate(params.target, 60)}`
  case 'snapshot': return `verbose=${String(params.verbose)}`
  case 'wait': return `ms=${truncate(String(params.ms), 20)}`
  case 'evaluate_script': return `script=${truncate(params.script, 120)}`
  case 'handle_dialog': return `action=${truncate(params.action, 20)}`
  case 'saveResult': case 'readResult': return `filename=${truncate(params.filename, 80)}`
  default: { try { return truncate(JSON.stringify(params), 200) } catch { return '' } }
 }
}

/**
 * Build unique action key combining tool, URL and params.
 * @param {{tool: string, params: object}} decision @param {object} ctx
 * @returns {string}
 */
const actionKeyForDecision = (decision, ctx) => {
 const tool = decision?.tool || 'unknown'
 const url = normalizeUrl(ctx?.currentUrl || '')
 return `${tool}|${url}|${decisionSignature(decision)}`
}

/**
 * Parse CLI flags into tool-specific params.
 * @param {{command: string, args: string[], flags: Record<string, string|true>}} parsed
 * @returns {object}
 */
const parseParams = ({ command, args, flags }) => {
 switch (command) {
  case 'navigate': return { url: flags.url || args[1] }
  case 'snapshot': return { verbose: toBoolean(flags.verbose, false) }
  case 'click': return { uid: flags.uid || args[1] }
  case 'fill': return { uid: flags.uid || args[1], text: flags.text || args[2] || '' }
  case 'open-link': return { uid: flags.uid || args[1] }
  case 'scroll': return { direction: flags.direction || args[1] || 'down', distance: Number(flags.distance || 500) }
  case 'tab': return { target: flags.target || args[1] || '0' }
  case 'proxy': return { action: args[1] || flags.action || 'status', reason: flags.reason || '' }
  case 'adblock': {
   const action = args[1] || flags.action || 'status'
   const patch = {
    enabled: flags.enabled !== undefined ? toBoolean(flags.enabled, true) : undefined,
    mode: flags.mode,
    blockUrlPatterns: flags.blockUrlPatterns ? parseList(flags.blockUrlPatterns) : undefined,
    allowlistDomains: flags.allowlistDomains ? parseList(flags.allowlistDomains) : undefined
   }
   return { action, mode: flags.mode, patch }
  }
  case 'fingerprint': return { config: safeJsonParse(flags.config, {}) || {} }
  case 'wait': return { ms: Number(flags.ms || args[1] || 0) }
  case 'extract': return { selector: flags.selector || args[1] || '' }
  case 'source': return { includeDoctype: toBoolean(flags.includeDoctype, true) }
  case 'eval': return { script: flags.script || args[1] || '' }
  case 'key': return { key: flags.key || args[1] || '' }
  case 'dialog': return { action: flags.action || args[1] || 'accept', promptText: flags.promptText || '' }
  case 'save': return { filename: flags.filename || args[1], content: flags.content || '', append: toBoolean(flags.append, false) }
  case 'read': return { filename: flags.filename || args[1] }
  case 'done': return { reason: flags.reason || args[1] || '' }
  default: return {}
 }
}

/**
 * Run CLI with given argv array.
 * @param {string[]} [argv] - Process arguments @param {object} [config] - Config overrides
 * @returns {Promise<number>} Exit code (0=success, 1=error)
 */
const runCli = async (argv = process.argv.slice(2), config = DEFAULT_CONFIG) => {
 const parsed = parseArgv(argv)
 if (!parsed.command || parsed.command === 'help' || parsed.command === '--help') {
  console.log(HELP_TEXT)
  return 0
 }

 const toolName = COMMAND_TO_TOOL[parsed.command]
 if (!toolName) {
  console.error(`${Colors.error}Unknown command: ${parsed.command}${Colors.reset}`)
  console.log(HELP_TEXT)
  return 1
 }

 const tools = createTools()
 const tool = tools[toolName]
 if (!tool) throw new Error(`Tool not implemented: ${toolName}`)

 const ctx = createAgentContext(config)
 const params = parseParams(parsed)
 const shouldInit = !['help', 'done'].includes(parsed.command)
 if (shouldInit && !ctx.browser) await ctx.init()

 try {
  const result = await tool.execute(ctx, params)
  console.log(JSON.stringify({ ok: true, tool: toolName, result }, null, 2))
  return 0
 } catch (error) {
  console.error(JSON.stringify({ ok: false, tool: toolName, error: error.message }, null, 2))
  return 1
 } finally {
  await ctx.close()
 }
}

export { runCli, COMMAND_TO_TOOL, decisionSignature, actionKeyForDecision, Colors }

===[END: {xd-chrome-cli.js}]===

===[START: {xd-chrome-core.js}]===
/**
 * @fileoverview Core browser agent context: config, init, tab management, stealth, proxy, adblock.
 * @module xd-chrome-core
 */

import { chromium } from 'playwright'
import { createLogger, toBoolean } from './xd-chrome-helpers.js'
import { createAdblockManager } from './xd-chrome-extended/xd-extended-adblock.js'
import { ProxyManager } from './xd-chrome-extended/xd-extended-proxy.js'
import { createFingerprintManager } from './xd-chrome-extended/xd-extended-fingerprinting.js'
import { createBehaviorEmulator } from './xd-chrome-extended/xd-extended-behavior.js'
import { createStealthSessionManager } from './xd-chrome-extended/xd-extended-stealth.js'
import { xdStealthUtils } from './xd-chrome-extended/xd-extended-stealth-helpers.js'

/** @type {object} Default configuration merged with user overrides */
const DEFAULT_CONFIG = {
 browser: {
  headless: true,
  viewport: { width: 1280, height: 800 },
  slowMo: 0,
  timeout: 30000,
  useCDP: false,
  cdpEndpoint: 'http://localhost:9222'
 },
 proxy: { enabled: false, urls: [] },
 adblock: {
  enabled: true,
  mode: 'balanced',
  blockResourceTypes: { balanced: ['media'], aggressive: ['image', 'media', 'font'] },
  blockUrlPatterns: ['doubleclick.net', 'googlesyndication.com', 'googleadservices.com', 'taboola.com', 'outbrain.com', 'criteo.com'],
  allowlistDomains: []
 },
 stealth: { enabled: true, deviceType: 'desktop', browserType: 'chrome', behaviorProfile: 'stealth' }
}

/** Well-known cookie consent selectors */
const COOKIE_SELECTORS = [
 '#onetrust-accept-btn-handler',
 '#CybotCookiebotDialogBodyLevelButtonLevelOptinAllowAll',
 '#L2AGLb',
 '.osano-cm-accept-all',
 '[data-testid="cookie-policy-dialog-accept-button"]',
 '[data-testid="GDPR-accept"]',
 'button[data-cookiebanner="accept_button"]'
]

/**
 * Create agent context with browser lifecycle, proxy, adblock and stealth.
 * @param {object} [config={}] - User config overrides
 * @param {object} [opts={}] - Extra options (logger, page for pooled mode)
 * @returns {object} Agent context
 */
const createAgentContext = (config = {}, opts = {}) => {
 const cfg = {
  ...DEFAULT_CONFIG,
  ...config,
  browser: { ...DEFAULT_CONFIG.browser, ...(config.browser || {}) },
  proxy: { ...DEFAULT_CONFIG.proxy, ...(config.proxy || {}) },
  adblock: { ...DEFAULT_CONFIG.adblock, ...(config.adblock || {}) },
  stealth: { ...DEFAULT_CONFIG.stealth, ...(config.stealth || {}) }
 }
 const logger = opts.logger || createLogger(false)

 const ctx = {
  config: cfg,
  logger,
  browser: null,
  page: opts.page || null,
  pages: opts.page ? [opts.page] : [],
  currentPageIndex: 0,
  currentUrl: 'about:blank',
  lastSnapshot: null,
  visitedUrls: new Set(['about:blank']),
  _proxyManager: null,
  _proxyLaunchRaw: null,
  _ownership: opts.ownership || 'standalone',
  adblock: null,
  stealthSession: null,
  fingerprintManager: createFingerprintManager(),
  behaviorEmulator: createBehaviorEmulator(),
  stealthManager: null,
  cookieState: { lastUrl: '', attempts: 0 },
  step: 0,
  lastError: null
 }

 /** @param {string} url - Add URL to visited set */
 ctx.addVisitedUrl = url => { if (url) ctx.visitedUrls.add(url) }
 /** @returns {string[]} All visited URLs */
 ctx.getVisitedUrls = () => Array.from(ctx.visitedUrls)

 /**
  * Switch to tab by numeric index or URL substring.
  * @param {number|string} indexOrUrl
  * @returns {Promise<boolean>}
  */
 ctx.switchToTab = async (indexOrUrl) => {
  if (typeof indexOrUrl === 'number') {
   if (indexOrUrl < 0 || indexOrUrl >= ctx.pages.length) return false
   ctx.page = ctx.pages[indexOrUrl]
   ctx.currentPageIndex = indexOrUrl
   ctx.currentUrl = ctx.page.url()
   logger.info(`Switched to tab ${indexOrUrl + 1}/${ctx.pages.length}`)
   return true
  }
  const needle = String(indexOrUrl || '')
  const idx = ctx.pages.findIndex(p => {
   try { return p.url().includes(needle) } catch { return false }
  })
  if (idx < 0) return false
  return ctx.switchToTab(idx)
 }

 /**
  * Auto-dismiss common cookie consent banners.
  * @param {object} [options] @param {boolean} [options.force=false]
  * @returns {Promise<{handled: boolean, clicks: number}>}
  */
 ctx.handleCookiePolicy = async (options = {}) => {
  if (!ctx.page) return { handled: false, clicks: 0 }
  let currentUrl = ''
  try { currentUrl = ctx.page.url() } catch {}
  const urlKey = currentUrl.split('#')[0]
  if (!options.force && ctx.cookieState.lastUrl === urlKey && ctx.cookieState.attempts >= 1) {
   return { handled: false, clicks: 0, skipped: true }
  }
  if (ctx.cookieState.lastUrl !== urlKey) { ctx.cookieState.lastUrl = urlKey; ctx.cookieState.attempts = 0 }
  ctx.cookieState.attempts += 1
  let clicks = 0
  for (const sel of COOKIE_SELECTORS) {
   try {
    const loc = ctx.page.locator(sel).first()
    if ((await loc.count()) === 0) continue
    if (!(await loc.isVisible().catch(() => false))) continue
    await loc.click({ timeout: 800, force: true })
    clicks++
   } catch {}
  }
  if (clicks > 0) logger.info(`Cookie handler: ${clicks} banner(s) dismissed`)
  return { handled: clicks > 0, clicks }
 }

 /**
  * Initialize browser (standalone or CDP), set up stealth, adblock, tab listeners.
  * @returns {Promise<void>}
  */
 ctx.init = async () => {
  const launchOpts = {
   headless: toBoolean(cfg.browser.headless, true),
   slowMo: Number(cfg.browser.slowMo) || 0,
   args: ['--disable-blink-features=AutomationControlled', '--no-sandbox']
  }

  // CDP mode: connect to existing Chrome
  if (cfg.browser.useCDP) {
   logger.info('Connecting to Chrome via CDP...')
   ctx.browser = await chromium.connectOverCDP(cfg.browser.cdpEndpoint || 'http://localhost:9222')
   const contexts = ctx.browser.contexts()
   if (contexts.length > 0) {
    ctx.page = contexts[0].pages()[0] || await contexts[0].newPage()
   } else {
    const context = await ctx.browser.newContext({ viewport: xdStealthUtils.getViewportFromConfig(cfg) })
    ctx.page = await context.newPage()
   }
  } else {
   // Proxy setup
   if (cfg.proxy.enabled) {
    ctx._proxyManager = new ProxyManager(cfg.proxy.urls || [])
    const proxy = ctx._proxyManager.getNextProxy()
    if (proxy) {
     launchOpts.proxy = { server: proxy.server, username: proxy.username, password: proxy.password }
     ctx._proxyLaunchRaw = proxy.raw
     logger.info(`Proxy: ${proxy.server}`)
    } else {
     logger.warn('Proxy enabled but no available proxies')
    }
   }
   ctx.browser = await chromium.launch(launchOpts)
   ctx.page = await ctx.browser.newPage({ viewport: xdStealthUtils.getViewportFromConfig(cfg) })
  }

  ctx.pages = [ctx.page]
  ctx.currentPageIndex = 0
  ctx.currentUrl = ctx.page.url()

  // Adblock
  ctx.adblock = createAdblockManager(cfg.adblock, logger)
  await ctx.adblock.install(ctx.page.context())

  // Stealth session
  ctx.stealthManager = createStealthSessionManager({
   fingerprintManager: ctx.fingerprintManager,
   behaviorEmulator: ctx.behaviorEmulator
  })
  if (cfg.stealth.enabled !== false) {
   ctx.stealthSession = await ctx.stealthManager.createSession(ctx.page, cfg.stealth)
  }

  // Track new tabs
  ctx.page.context().on('page', newPage => {
   if (ctx.pages.includes(newPage)) return
   ctx.pages.push(newPage)
   logger.info(`New tab opened (${ctx.pages.length} tabs)`)
  })

  // Log page console errors
  ctx.page.on('console', msg => {
   if (msg.type() === 'error' || msg.type() === 'warning') {
    const text = msg.text()
    if (!text.includes('Third-party cookie') && !text.includes('preload')) {
     logger.warn(`Console ${msg.type()}: ${text.slice(0, 200)}`)
    }
   }
  })

  logger.success('Browser ready')
 }

 /**
  * Rotate proxy: report failure, close browser, re-init.
  * @returns {Promise<boolean>}
  */
 ctx.rotateBrowser = async () => {
  if (!ctx._proxyManager) return false
  if (ctx._proxyLaunchRaw) ctx._proxyManager.reportFailure(ctx._proxyLaunchRaw)
  logger.info('Rotating proxy — restarting browser...')
  await ctx.close()
  await ctx.init()
  return true
 }

 /**
  * Get live status for monitoring.
  * @returns {object}
  */
 ctx.getLiveStatus = () => ({
  step: ctx.step,
  url: ctx.currentUrl,
  tabs: ctx.pages.length,
  visitedCount: ctx.visitedUrls.size,
  adblock: ctx.adblock?.getStatus?.() || { enabled: false },
  lastError: ctx.lastError,
  ts: Date.now()
 })

 /** Close browser and cleanup. Pooled mode skips browser.close(). */
 ctx.close = async () => {
  if (ctx._ownership === 'pooled') {
   ctx.page = null; ctx.pages = []; return
  }
  if (ctx.browser) await ctx.browser.close()
  ctx.browser = null
  ctx.page = null
  ctx.pages = []
 }

 return ctx
}

export { createAgentContext, DEFAULT_CONFIG }

===[END: {xd-chrome-core.js}]===

===[START: {xd-chrome-extended/xd-extended-adblock.js}]===
/**
 * @fileoverview Adblock manager with request interception, LRU stats, multi-context support.
 * @module xd-extended-adblock
 */

/** @param {*} value @returns {string[]} Normalized lowercase array */
const normalizeArray = value => (Array.isArray(value) ? value : []).map(v => String(v || '').trim().toLowerCase()).filter(Boolean)

/** @param {string} mode @returns {'balanced'|'aggressive'} */
const normalizeMode = mode => String(mode || 'balanced').toLowerCase() === 'aggressive' ? 'aggressive' : 'balanced'

/** @param {string} value @returns {string} Cleaned domain */
const normalizeDomain = value => String(value || '').trim().toLowerCase().replace(/^\*\./, '').replace(/\.+$/, '')

/** @param {string} host @param {string} domain @returns {boolean} */
const hostMatchesDomain = (host, domain) => {
 const h = normalizeDomain(host), d = normalizeDomain(domain)
 return !!(h && d && (h === d || h.endsWith(`.${d}`)))
}

/**
 * Simple LRU map for tracking blocked hosts.
 * @param {number} [maxSize=500] @returns {object}
 */
const createLRUMap = (maxSize = 500) => {
 const map = new Map()
 return {
  get: key => map.get(key),
  inc: key => {
   const next = (map.get(key) || 0) + 1
   if (map.has(key)) map.delete(key)
   else if (map.size >= maxSize) { const k = map.keys().next().value; if (k !== undefined) map.delete(k) }
   map.set(key, next); return next
  },
  entries: () => Array.from(map.entries()),
  clear: () => map.clear()
 }
}

/**
 * Create adblock manager with request interception.
 * @param {object} [initialConfig={}] - Adblock configuration
 * @param {object} [logger=console] - Logger instance
 * @returns {object} Manager API: install, uninstall, setMode, setEnabled, updateConfig, resetStats, getStatus
 */
const createAdblockManager = (initialConfig = {}, logger = console) => {
 const config = {
  enabled: true,
  mode: 'balanced',
  blockResourceTypes: { balanced: ['media'], aggressive: ['image', 'media', 'font'] },
  blockUrlPatterns: ['doubleclick.net', 'googlesyndication.com', 'googleadservices.com', 'taboola.com', 'outbrain.com', 'criteo.com', 'adnxs.com'],
  allowlistDomains: [],
  logEveryBlocked: 25,
  ...initialConfig
 }

 const installedContexts = new Map()
 let stats = { blocked: 0, allowed: 0, blockedByType: {}, blockedByHost: createLRUMap(500) }

 /** Build optimized lookup cache from current config */
 const buildCache = () => {
  const mode = normalizeMode(config.mode)
  const allPatterns = normalizeArray(config.blockUrlPatterns || [])
  const domainPatterns = allPatterns.filter(p => !p.includes('/') && !p.includes('?'))
  const urlPatterns = allPatterns.filter(p => p.includes('/') || p.includes('?'))
  return {
   enabled: config.enabled !== false, mode,
   blockedTypes: new Set(normalizeArray(config.blockResourceTypes?.[mode] || [])),
   domainPatterns: domainPatterns.map(normalizeDomain),
   urlPatterns,
   allowlistDomains: normalizeArray(config.allowlistDomains || []).map(normalizeDomain)
  }
 }

 let cache = buildCache()

 /** @param {import('playwright').Request} request @returns {{block: boolean, host?: string, resourceType?: string, blockRule?: string}} */
 const evaluate = request => {
  const url = String(request.url() || '').toLowerCase()
  if (!cache.enabled || !url || url.startsWith('data:') || url.startsWith('blob:') || url.startsWith('about:')) return { block: false }
  let host = ''
  try { host = normalizeDomain(new URL(url).hostname) } catch {}
  if (host && cache.allowlistDomains.some(d => hostMatchesDomain(host, d))) return { block: false }
  const resourceType = String(request.resourceType() || '').toLowerCase()
  if (cache.blockedTypes.has(resourceType)) return { block: true, host, resourceType, blockRule: `type:${resourceType}` }
  if (resourceType !== 'document') {
   const matchDomain = cache.domainPatterns.find(p => hostMatchesDomain(host, p))
   if (matchDomain) return { block: true, host, resourceType, blockRule: `domain:${matchDomain}` }
   const matchUrl = cache.urlPatterns.find(p => url.includes(p))
   if (matchUrl) return { block: true, host, resourceType, blockRule: `pattern:${matchUrl}` }
  }
  return { block: false }
 }

 /** @param {import('playwright').Route} route */
 const handler = async route => {
  const decision = evaluate(route.request())
  if (!decision.block) { stats.allowed += 1; return route.continue() }
  stats.blocked += 1
  if (decision.host) stats.blockedByHost.inc(decision.host)
  if (decision.resourceType) stats.blockedByType[decision.resourceType] = (stats.blockedByType[decision.resourceType] || 0) + 1
  if (stats.blocked % (config.logEveryBlocked || 25) === 0) {
   logger.info?.(`Adblock: blocked=${stats.blocked} allowed=${stats.allowed} mode=${cache.mode}`)
  }
  try { await route.abort('blockedbyclient') } catch { await route.abort() }
 }

 /** @param {import('playwright').BrowserContext} browserContext @returns {Promise<boolean>} */
 const install = async browserContext => {
  if (!browserContext || installedContexts.has(browserContext)) return true
  const bound = route => handler(route)
  await browserContext.route('**/*', bound)
  installedContexts.set(browserContext, bound)
  logger.info?.(`Adblock installed (${cache.mode})`)
  return true
 }

 /** @param {import('playwright').BrowserContext} browserContext @returns {Promise<boolean>} */
 const uninstall = async browserContext => {
  if (!browserContext || !installedContexts.has(browserContext)) return false
  const bound = installedContexts.get(browserContext)
  await browserContext.unroute('**/*', bound)
  installedContexts.delete(browserContext)
  return true
 }

 /** Reinstall handler on all tracked contexts (after config change) */
 const reinstallAll = async () => {
  for (const context of Array.from(installedContexts.keys())) {
   try { await uninstall(context); await install(context) } catch {}
  }
 }

 /** @param {object} patch @returns {Promise<object>} Updated status */
 const updateConfig = async patch => {
  Object.assign(config, patch || {})
  cache = buildCache()
  await reinstallAll()
  return getStatus()
 }

 const setMode = async mode => updateConfig({ mode: normalizeMode(mode) })
 const setEnabled = async enabled => updateConfig({ enabled: Boolean(enabled) })

 const resetStats = () => {
  stats = { blocked: 0, allowed: 0, blockedByType: {}, blockedByHost: createLRUMap(500) }
  return getStatus()
 }

 /** @returns {object} Current adblock status with stats */
 const getStatus = () => {
  const topHosts = stats.blockedByHost.entries().sort((a, b) => b[1] - a[1]).slice(0, 10).map(([host, count]) => ({ host, count }))
  return {
   enabled: cache.enabled, mode: cache.mode,
   rules: { blockResourceTypes: config.blockResourceTypes, blockUrlPatterns: config.blockUrlPatterns, allowlistDomains: config.allowlistDomains },
   stats: { blocked: stats.blocked, allowed: stats.allowed, blockedByType: { ...stats.blockedByType }, topBlockedHosts: topHosts }
  }
 }

 return { install, uninstall, setMode, setEnabled, updateConfig, resetStats, getStatus }
}

export { createAdblockManager }

===[END: {xd-chrome-extended/xd-extended-adblock.js}]===

===[START: {xd-chrome-extended/xd-extended-behavior.js}]===
/**
 * @fileoverview Human-like behavior emulation: typing delays, scroll pauses, profile rotation.
 * @module xd-extended-behavior
 */

import { STEALTH_CONFIG, xdStealthUtils } from './xd-extended-stealth-helpers.js'
import { sleep } from '../xd-chrome-helpers.js'

/**
 * Create behavior emulator with multiple profiles (stealth/casual/researcher).
 * @returns {{setProfile: Function, rotateProfile: Function, shouldSwitchProfile: Function, emulateTyping: Function, emulateScroll: Function, getBehaviorMetrics: Function}}
 */
const createBehaviorEmulator = () => {
 /** @type {Record<string, {clickDelay: {min: number, max: number}, typeDelay: {min: number, max: number}, scrollPause: {min: number, max: number}}>} */
 const profiles = {
  stealth: { clickDelay: { min: 250, max: 1100 }, typeDelay: { min: 50, max: 140 }, scrollPause: { min: 80, max: 320 } },
  casual: { clickDelay: { min: 450, max: 1800 }, typeDelay: { min: 70, max: 180 }, scrollPause: { min: 120, max: 450 } },
  researcher: { clickDelay: { min: 800, max: 2600 }, typeDelay: { min: 80, max: 200 }, scrollPause: { min: 150, max: 600 } }
 }

 let currentProfile = 'stealth'
 let lastSwitch = 0

 /** @param {string} name @returns {boolean} */
 const setProfile = (name) => {
  if (!profiles[name]) return false
  currentProfile = name
  lastSwitch = Date.now()
  return true
 }

 /** @returns {string} New active profile name */
 const rotateProfile = () => {
  const keys = Object.keys(profiles)
  const idx = keys.indexOf(currentProfile)
  const next = keys[(idx + 1) % keys.length]
  setProfile(next)
  return next
 }

 /** @returns {boolean} Whether enough time has passed for a profile switch */
 const shouldSwitchProfile = () => Date.now() - lastSwitch > STEALTH_CONFIG.BEHAVIOR_SWITCH_INTERVAL

 /**
  * Emulate human-like typing with per-character delays.
  * @param {import('playwright').Page} page @param {string} selector @param {string} text
  */
 const emulateTyping = async (page, selector, text) => {
  if (!page || !selector) return
  const p = profiles[currentProfile]
  await page.click(selector)
  for (const char of String(text || '')) {
   await page.keyboard.type(char)
   await sleep(xdStealthUtils.randomInt(p.typeDelay.min, p.typeDelay.max))
  }
 }

 /**
  * Emulate human-like scrolling with pause after.
  * @param {import('playwright').Page} page @param {number} [distance=500] @param {string} [direction='down']
  */
 const emulateScroll = async (page, distance = 500, direction = 'down') => {
  if (!page) return
  const p = profiles[currentProfile]
  const amount = Math.max(10, Number(distance) || 500)
  const sign = direction === 'up' ? -1 : 1
  await page.mouse.wheel(0, sign * amount)
  await sleep(xdStealthUtils.randomInt(p.scrollPause.min, p.scrollPause.max))
 }

 /** @returns {{profile: string, sinceSwitchMs: number}} */
 const getBehaviorMetrics = () => ({
  profile: currentProfile,
  sinceSwitchMs: Date.now() - lastSwitch
 })

 return { setProfile, rotateProfile, shouldSwitchProfile, emulateTyping, emulateScroll, getBehaviorMetrics }
}

export { createBehaviorEmulator }

===[END: {xd-chrome-extended/xd-extended-behavior.js}]===

===[START: {xd-chrome-extended/xd-extended-fingerprinting.js}]===
/**
 * @fileoverview Fingerprint manager: generate, cache, and inject browser fingerprints.
 * @module xd-extended-fingerprinting
 */

import { STEALTH_CONFIG, xdStealthUtils } from './xd-extended-stealth-helpers.js'

/** User agent pools by device/browser type */
const XD_USER_AGENTS = {
 desktop: {
  chrome: [
   'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0.0.0 Safari/537.36',
   'Mozilla/5.0 (Windows NT 11.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0.0.0 Safari/537.36',
   'Mozilla/5.0 (Macintosh; Intel Mac OS X 14_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0.0.0 Safari/537.36',
   'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0.0.0 Safari/537.36'
  ],
  firefox: [
   'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:125.0) Gecko/20100101 Firefox/125.0',
   'Mozilla/5.0 (Macintosh; Intel Mac OS X 14.4; rv:125.0) Gecko/20100101 Firefox/125.0'
  ],
  edge: [
   'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0.0.0 Safari/537.36 Edg/124.0.0.0'
  ]
 },
 mobile: {
  chrome: [
   'Mozilla/5.0 (Linux; Android 14; Pixel 8 Pro) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0.0.0 Mobile Safari/537.36',
   'Mozilla/5.0 (Linux; Android 14; SM-S928B) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0.0.0 Mobile Safari/537.36'
  ],
  safari: [
   'Mozilla/5.0 (iPhone; CPU iPhone OS 17_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.4 Mobile/15E148 Safari/604.1'
  ]
 }
}

/**
 * Create fingerprint manager with generation, caching and page injection.
 * @returns {{generate: Function, getCurrent: Function, injectIntoPage: Function}}
 */
const createFingerprintManager = () => {
 const state = { current: null, lastUpdate: 0 }

 /** @param {string} ua @returns {string} Platform string derived from UA */
 const extractPlatform = (ua) => {
  if (ua.includes('Windows')) return 'Win32'
  if (ua.includes('Macintosh')) return 'MacIntel'
  if (ua.includes('Android')) return 'Linux armv8l'
  return 'Linux x86_64'
 }

 /** Simple string hash → base36 */
 const hash = (value) => {
  let result = 0
  for (let i = 0; i < value.length; i++) result = ((result << 5) - result) + value.charCodeAt(i)
  return Math.abs(result).toString(36)
 }

 /**
  * Generate new fingerprint.
  * @param {object} [config={}] @param {string} [config.deviceType='desktop'] @param {string} [config.browserType='chrome']
  * @returns {object} Fingerprint with userAgent, platform, screen, viewport, hash, etc.
  */
 const generate = (config = {}) => {
  const deviceType = config.deviceType || 'desktop'
  const browserType = config.browserType || 'chrome'
  const uaPool = XD_USER_AGENTS[deviceType]?.[browserType] || XD_USER_AGENTS.desktop.chrome
  const userAgent = xdStealthUtils.randomChoice(uaPool)
  const screen = deviceType === 'mobile'
   ? { width: 390, height: 844, devicePixelRatio: 3 }
   : { width: xdStealthUtils.randomChoice([1920, 2560, 1440]), height: 1080, devicePixelRatio: 1 }
  const viewport = { width: Math.max(320, screen.width - 80), height: Math.max(320, screen.height - 120) }
  const fingerprint = {
   userAgent, deviceType, browserType,
   platform: extractPlatform(userAgent),
   timezone: xdStealthUtils.randomChoice(STEALTH_CONFIG.TIMEZONES),
   languages: ['en-US', 'en'],
   webgl: { vendor: xdStealthUtils.randomChoice(STEALTH_CONFIG.WEBGL_VENDORS), renderer: `WebGL ${xdStealthUtils.randomInt(1, 2)}.${xdStealthUtils.randomInt(0, 9)}` },
   hardware: { concurrency: deviceType === 'mobile' ? 8 : xdStealthUtils.randomChoice([8, 12, 16]), memory: deviceType === 'mobile' ? 8 : 16, maxTouchPoints: deviceType === 'mobile' ? 5 : 0 },
   screen, viewport,
   hash: hash(`${userAgent}|${screen.width}x${screen.height}|${viewport.width}x${viewport.height}`),
   generatedAt: Date.now()
  }
  state.current = fingerprint
  state.lastUpdate = Date.now()
  return fingerprint
 }

 /** @returns {object} Current fingerprint (auto-regenerates if expired) */
 const getCurrent = () => {
  if (!state.current || Date.now() - state.lastUpdate > STEALTH_CONFIG.FINGERPRINT_UPDATE_INTERVAL) return generate()
  return state.current
 }

 /**
  * Inject fingerprint overrides into page via addInitScript.
  * @param {import('playwright').Page} page @param {object} [fingerprint]
  */
 const injectIntoPage = async (page, fingerprint = state.current) => {
  if (!page || !fingerprint) return
  await page.addInitScript((fp) => {
   Object.defineProperty(navigator, 'userAgent', { get: () => fp.userAgent })
   Object.defineProperty(navigator, 'platform', { get: () => fp.platform })
   Object.defineProperty(navigator, 'languages', { get: () => fp.languages })
   Object.defineProperty(navigator, 'hardwareConcurrency', { get: () => fp.hardware.concurrency })
   Object.defineProperty(navigator, 'webdriver', { get: () => false })
  }, fingerprint)
 }

 return { generate, getCurrent, injectIntoPage }
}

export { createFingerprintManager }

===[END: {xd-chrome-extended/xd-extended-fingerprinting.js}]===

===[START: {xd-chrome-extended/xd-extended-proxy.js}]===
/**
 * @fileoverview Proxy manager with failure tracking, auto-banning, and rotation.
 * @module xd-extended-proxy
 */

import { readFileSync, writeFileSync, existsSync, mkdirSync } from 'fs'
import { join, dirname } from 'path'

/** Failures within this window count toward ban */
const FAIL_THRESHOLD = 3
/** @type {number} 1 hour failure window */
const FAIL_WINDOW_MS = 60 * 60 * 1000
/** @type {number} 12 hour ban duration */
const BAN_DURATION_MS = 12 * 60 * 60 * 1000

/**
 * Proxy manager with round-robin rotation, failure tracking, and persistent bans.
 * @param {string[]} cfgUrls - Proxy URLs (protocol://user:pass@host:port)
 * @param {string} [dataDir='./data_arch'] - Directory for persisting ban state
 */
class ProxyManager {
 constructor (cfgUrls = [], dataDir = './data_arch') {
  this._allUrls = [...new Set((Array.isArray(cfgUrls) ? cfgUrls : []).map(v => String(v || '').trim()).filter(Boolean))]
  this._index = 0
  this._current = null
  /** @type {Record<string, number[]>} Recent failure timestamps per proxy */
  this._failures = {}
  this._state = { banned: {}, lastRotation: 0 }
  this._bansFile = join(dataDir, 'proxies.json')
  this._load()
  this._shuffle()
 }

 /** Fisher-Yates shuffle to randomize initial order */
 _shuffle () {
  const arr = this._allUrls
  for (let i = arr.length - 1; i > 0; i--) {
   const j = Math.floor(Math.random() * (i + 1))
   ;[arr[i], arr[j]] = [arr[j], arr[i]]
  }
 }

 /** Load ban state from disk, clean expired bans */
 _load () {
  try {
   if (existsSync(this._bansFile)) {
    this._state = JSON.parse(readFileSync(this._bansFile, 'utf-8'))
    if (!this._state.banned) this._state.banned = {}
   }
  } catch {}
  // Clean expired bans on load
  const now = Date.now()
  for (const [url, ban] of Object.entries(this._state.banned)) {
   if (ban.expiresAt && ban.expiresAt <= now) delete this._state.banned[url]
  }
 }

 /** Persist ban state to disk */
 save () {
  try {
   mkdirSync(dirname(this._bansFile), { recursive: true })
   writeFileSync(this._bansFile, JSON.stringify(this._state, null, 2), 'utf-8')
  } catch {}
 }

 /** @param {string} url @returns {boolean} Whether proxy is currently banned */
 _isBanned (url) {
  const ban = this._state.banned[url]
  if (!ban) return false
  if (Date.now() >= ban.expiresAt) { delete this._state.banned[url]; return false }
  return true
 }

 /**
  * Parse proxy URL into components.
  * @param {string} raw @returns {{raw: string, server: string, username: string, password: string}|null}
  */
 _parseProxy (raw) {
  try {
   const parsed = new URL(raw)
   return {
    raw,
    server: `${parsed.protocol}//${parsed.host}`,
    username: decodeURIComponent(parsed.username),
    password: decodeURIComponent(parsed.password)
   }
  } catch { return null }
 }

 /** @returns {object|null} Next available proxy (round-robin), or null if all banned */
 getNextProxy () {
  const available = this._allUrls.filter(url => !this._isBanned(url))
  if (!available.length) return null
  this._index = (this._index + 1) % available.length
  this._current = available[this._index]
  this._state.lastRotation = Date.now()
  return this._parseProxy(this._current)
 }

 /** @returns {object|null} Currently active parsed proxy */
 getCurrentProxy () {
  if (!this._current) return null
  return this._parseProxy(this._current)
 }

 /** @returns {string|null} Raw URL of current proxy */
 getCurrentProxyUrl () { return this._current }

 /**
  * Report proxy failure. Bans proxy after FAIL_THRESHOLD failures within window.
  * @param {string} proxyUrl @returns {boolean} true if proxy was banned
  */
 reportFailure (proxyUrl) {
  if (!proxyUrl) return false
  const now = Date.now()
  if (!this._failures[proxyUrl]) this._failures[proxyUrl] = []
  this._failures[proxyUrl].push(now)
  this._failures[proxyUrl] = this._failures[proxyUrl].filter(ts => now - ts < FAIL_WINDOW_MS)
  if (this._failures[proxyUrl].length < FAIL_THRESHOLD) return false
  this._state.banned[proxyUrl] = { bannedAt: now, expiresAt: now + BAN_DURATION_MS, failures: this._failures[proxyUrl].length }
  delete this._failures[proxyUrl]
  this.save()
  return true
 }

 /** @param {string} proxyUrl - Clear failure history on success */
 reportSuccess (proxyUrl) {
  if (!proxyUrl) return
  delete this._failures[proxyUrl]
 }

 /** @returns {{total: number, available: number, banned: number}} Pool stats */
 getStats () {
  const now = Date.now()
  const banned = Object.values(this._state.banned).filter(b => b.expiresAt > now).length
  return { total: this._allUrls.length, available: this._allUrls.length - banned, banned }
 }
}

export { ProxyManager }
===[END: {xd-chrome-extended/xd-extended-proxy.js}]===

===[START: {xd-chrome-extended/xd-extended-stealth-helpers.js}]===
/**
 * @fileoverview Stealth configuration constants and utility functions.
 * @module xd-extended-stealth-helpers
 */

/** @type {object} Timing and data constants for stealth operations */
const STEALTH_CONFIG = {
 /** @type {number} 5 min - regenerate fingerprint interval */
 FINGERPRINT_UPDATE_INTERVAL: 5 * 60 * 1000,
 /** @type {number} 10 min - behavior profile switch interval */
 BEHAVIOR_SWITCH_INTERVAL: 10 * 60 * 1000,
 MAX_CANVAS_NOISE_INTENSITY: 0.15,
 MIN_CANVAS_NOISE_INTENSITY: 0.02,
 WEBGL_VENDORS: ['Intel Inc.', 'NVIDIA Corporation', 'AMD', 'Apple', 'Microsoft', 'ARM', 'Qualcomm'],
 TIMEZONES: ['Europe/Warsaw', 'Europe/London', 'Europe/Paris', 'America/New_York', 'America/Los_Angeles', 'Asia/Tokyo']
}

/** Stealth utility functions */
const xdStealthUtils = {
 /** @param {number} min @param {number} max @returns {number} Random int in [min, max] */
 randomInt: (min, max) => Math.floor(Math.random() * (max - min + 1)) + min,
 /** @param {Array} arr @returns {*} Random element */
 randomChoice: arr => arr[Math.floor(Math.random() * arr.length)],
 /**
  * Weighted random choice.
  * @param {Array} items @param {number[]} weights @returns {*}
  */
 weightedChoice: (items, weights) => {
  const total = weights.reduce((a, b) => a + b, 0)
  let r = Math.random() * total
  for (let i = 0; i < items.length; i++) { if (r < weights[i]) return items[i]; r -= weights[i] }
  return items[items.length - 1]
 },
 /** @returns {number} Unique seed based on time + random */
 generateSeed: () => Date.now() + Math.floor(Math.random() * 1000000),
 /** @param {Function} fn @returns {Function} Memoized version */
 memoize: (fn) => {
  const cache = new Map()
  return (...args) => { const k = JSON.stringify(args); if (cache.has(k)) return cache.get(k); const r = fn(...args); cache.set(k, r); return r }
 },
 /** @param {object} config @returns {{width: number, height: number}} Viewport from config */
 getViewportFromConfig: (config) => ({
  width: config?.browser?.viewport?.width || 1280,
  height: config?.browser?.viewport?.height || 800
 })
}

export { STEALTH_CONFIG, xdStealthUtils }

===[END: {xd-chrome-extended/xd-extended-stealth-helpers.js}]===

===[START: {xd-chrome-extended/xd-extended-stealth.js}]===
/**
 * @fileoverview Stealth session manager: binds fingerprint, behavior, and detection per page.
 * @module xd-extended-stealth
 */

import { createFingerprintManager } from './xd-extended-fingerprinting.js'
import { createBehaviorEmulator } from './xd-extended-behavior.js'

/**
 * Create stealth session manager.
 * @param {object} [deps={}]
 * @param {object} [deps.fingerprintManager] - Fingerprint manager instance
 * @param {object} [deps.behaviorEmulator] - Behavior emulator instance
 * @returns {{createSession: Function, getSessionMetrics: Function, closeSession: Function, detectStealthIssues: Function}}
 */
const createStealthSessionManager = ({ fingerprintManager, behaviorEmulator } = {}) => {
 const fp = fingerprintManager || createFingerprintManager()
 const behavior = behaviorEmulator || createBehaviorEmulator()
 /** @type {Map<string, object>} Active sessions */
 const sessions = new Map()

 /**
  * Create a new stealth session for a page.
  * @param {import('playwright').Page} page
  * @param {object} [config={}] @param {string} [config.behaviorProfile='stealth']
  * @returns {Promise<object>} Session with emulateTyping, emulateScroll, rotateProfile, etc.
  */
 const createSession = async (page, config = {}) => {
  const id = config.sessionId || `xd-stealth-${Date.now()}-${Math.random().toString(36).slice(2, 10)}`
  const fingerprint = fp.generate(config)
  behavior.setProfile(config.behaviorProfile || 'stealth')
  await fp.injectIntoPage(page, fingerprint)
  const session = {
   id, page, fingerprint,
   behaviorProfile: config.behaviorProfile || 'stealth',
   createdAt: new Date(), lastActivity: new Date(),
   metrics: { pageLoads: 0, fingerprintChanges: 0 }
  }
  sessions.set(id, session)
  return {
   ...session,
   /** @param {string} selector @param {string} text */
   emulateTyping: (selector, text) => behavior.emulateTyping(page, selector, text),
   /** @param {number} distance @param {string} direction */
   emulateScroll: (distance, direction) => behavior.emulateScroll(page, distance, direction),
   rotateProfile: () => behavior.rotateProfile(),
   detectStealthIssues: () => detectStealthIssues(page),
   getMetrics: () => getSessionMetrics(id),
   close: () => closeSession(id)
  }
 }

 /** @param {string} sessionId @returns {object|null} */
 const getSessionMetrics = (sessionId) => {
  const session = sessions.get(sessionId)
  if (!session) return null
  return {
   ...session.metrics,
   behaviorProfile: behavior.getBehaviorMetrics().profile,
   fingerprintHash: session.fingerprint.hash
  }
 }

 /** @param {string} sessionId @returns {boolean} */
 const closeSession = (sessionId) => {
  sessions.delete(sessionId)
  return true
 }

 /**
  * Detect stealth issues on a page (webdriver, plugin count, etc).
  * @param {import('playwright').Page} page
  * @returns {Promise<{issues: object[], timestamp: string}>}
  */
 const detectStealthIssues = async (page) => {
  if (!page) return { issues: [] }
  const issues = []
  try {
   const navProps = await page.evaluate(() => ({
    webdriver: navigator.webdriver,
    plugins: navigator.plugins.length,
    languages: navigator.languages,
    platform: navigator.platform
   }))
   if (navProps.webdriver !== false && navProps.webdriver !== undefined) {
    issues.push({ type: 'webdriver', severity: 'high', message: 'Webdriver property detected' })
   }
   if (navProps.plugins < 3) {
    issues.push({ type: 'plugins', severity: 'medium', message: `Low plugin count: ${navProps.plugins}` })
   }
  } catch (error) {
   issues.push({ type: 'evaluation', severity: 'high', message: error.message })
  }
  return { issues, timestamp: new Date().toISOString() }
 }

 return { createSession, getSessionMetrics, closeSession, detectStealthIssues }
}

export { createStealthSessionManager }

===[END: {xd-chrome-extended/xd-extended-stealth.js}]===

===[START: {xd-chrome-helpers.js}]===
/** @param {number} ms - Delay in milliseconds @returns {Promise<void>} */
const sleep = ms => new Promise(resolve => setTimeout(resolve, Math.max(0, Number(ms) || 0)))

/** @param {*} value @param {boolean} [fallback=false] @returns {boolean} */
const toBoolean = (value, fallback = false) => {
 if (value === undefined || value === null) return fallback
 if (typeof value === 'boolean') return value
 const normalized = String(value).trim().toLowerCase()
 if (['1', 'true', 'yes', 'on'].includes(normalized)) return true
 if (['0', 'false', 'no', 'off'].includes(normalized)) return false
 return fallback
}

/** @param {number} value @param {number} min @param {number} max @returns {number} */
const clamp = (value, min, max) => Math.max(min, Math.min(max, Number(value) || min))

/** @param {string} str @param {number} [max=120] @returns {string} */
const truncate = (str, max = 120) => {
 const s = str === null || str === undefined ? '' : String(str)
 return s.length > max ? s.slice(0, max) + '\u2026' : s
}

/**
 * Parse CLI argv into args, flags and command.
 * @param {string[]} [argv=[]] @returns {{ args: string[], flags: Record<string, string|true>, command: string }}
 */
const parseArgv = (argv = []) => {
 const args = []
 const flags = {}
 for (let i = 0; i < argv.length; i++) {
  const token = argv[i]
  if (!token.startsWith('--')) {
   args.push(token)
   continue
  }
  const key = token.slice(2)
  const next = argv[i + 1]
  if (!next || next.startsWith('--')) {
   flags[key] = true
   continue
  }
  flags[key] = next
  i += 1
 }
 return { args, flags, command: args[0] || 'help' }
}

/** @param {string} value - Comma-separated string @returns {string[]} */
const parseList = value => String(value || '').split(',').map(v => v.trim()).filter(Boolean)

/** @param {string} value @param {*} [fallback=null] @returns {*} Parsed JSON or fallback */
const safeJsonParse = (value, fallback = null) => {
 if (!value || typeof value !== 'string') return fallback
 try { return JSON.parse(value) } catch { return fallback }
}

/**
 * Normalize URL: strip hash, return canonical form.
 * @param {string} url @returns {string}
 */
const normalizeUrl = (url) => {
 if (!url || typeof url !== 'string') return ''
 try { const u = new URL(url.trim()); u.hash = ''; return u.toString() } catch { return url.trim() }
}

/**
 * Create simple logger with colored prefixes.
 * @param {boolean} [silent=false] @returns {{ info: Function, warn: Function, error: Function, success: Function }}
 */
const createLogger = (silent = false) => ({
 info: (...parts) => { if (!silent) console.log('\x1b[36m[info]\x1b[0m', ...parts) },
 warn: (...parts) => { if (!silent) console.warn('\x1b[33m[warn]\x1b[0m', ...parts) },
 error: (...parts) => { if (!silent) console.error('\x1b[31m[error]\x1b[0m', ...parts) },
 success: (...parts) => { if (!silent) console.log('\x1b[32m[ok]\x1b[0m', ...parts) }
})

export { sleep, toBoolean, clamp, truncate, parseArgv, parseList, safeJsonParse, normalizeUrl, createLogger }

===[END: {xd-chrome-helpers.js}]===

===[START: {xd-chrome-tools-schema.js}]===
/**
 * @fileoverview Tool definitions (name, description, parameter schema) for xd-chrome agent.
 * @module xd-chrome-tools-schema
 */

/** @type {Record<string, {name: string, description: string, schema: Record<string, object>}>} */
const ToolsSchema = {
 init: { name: 'init', description: 'Initialize browser runtime', schema: {} },
 close: { name: 'close', description: 'Close browser runtime', schema: {} },
 navigate: {
  name: 'navigate',
  description: 'Navigate to URL (auto-snapshots after load)',
  schema: { url: { type: 'string', description: 'Full URL to navigate to', required: true } }
 },
 snapshot: {
  name: 'snapshot',
  description: 'Take accessibility snapshot (preferred over screenshot)',
  schema: { verbose: { type: 'boolean', description: 'Include extra detail', required: false } }
 },
 click: {
  name: 'click',
  description: 'Click element by uid from snapshot',
  schema: { uid: { type: 'string', description: 'Element ID from snapshot (e.g. el_5)', required: true } }
 },
 fill: {
  name: 'fill',
  description: 'Fill input field by uid from snapshot',
  schema: {
   uid: { type: 'string', description: 'Element ID of input field', required: true },
   text: { type: 'string', description: 'Text to type into the field', required: true }
  }
 },
 openLink: {
  name: 'openLink',
  description: 'Open link by uid via direct navigation (use href instead of click)',
  schema: { uid: { type: 'string', description: 'Element ID of link from snapshot', required: true } }
 },
 scroll: {
  name: 'scroll',
  description: 'Scroll current page (clears snapshot)',
  schema: {
   direction: { type: 'string', enum: ['down', 'up', 'bottom'], description: 'Scroll direction', required: false },
   distance: { type: 'number', description: 'Pixels to scroll (default 500)', required: false }
  }
 },
 switchToTab: {
  name: 'switchToTab',
  description: 'Switch tab by index (0-based) or URL fragment',
  schema: { target: { type: 'string', description: 'Tab index or URL fragment to match', required: true } }
 },
 proxyControl: {
  name: 'proxyControl',
  description: 'Check proxy status or rotate proxy/browser session',
  schema: {
   action: { type: 'string', enum: ['status', 'rotate'], description: 'Proxy action', required: true },
   reason: { type: 'string', description: 'Optional reason for logs', required: false }
  }
 },
 adblockControl: {
  name: 'adblockControl',
  description: 'Check or change adblock config/state (mode, enabled, rules, stats)',
  schema: {
   action: { type: 'string', enum: ['status', 'enable', 'disable', 'setMode', 'updateConfig', 'resetStats'], description: 'Adblock action', required: true },
   mode: { type: 'string', enum: ['balanced', 'aggressive'], description: 'Mode for setMode', required: false },
   enabled: { type: 'boolean', description: 'Explicit enabled flag for updateConfig', required: false },
   blockUrlPatterns: { type: 'array', description: 'URL/domain block patterns', required: false },
   allowlistDomains: { type: 'array', description: 'Allowlist domains', required: false }
  }
 },
 wait: {
  name: 'wait',
  description: 'Wait for specified milliseconds',
  schema: { ms: { type: 'number', description: 'Milliseconds to wait', required: true } }
 },
 extractContent: {
  name: 'extractContent',
  description: 'Extract readable text from current page (articles, regulations, main content)',
  schema: { selector: { type: 'string', description: 'CSS selector (default: body)', required: false } }
 },
 getSource: {
  name: 'getSource',
  description: 'Get raw HTML source of current page',
  schema: { includeDoctype: { type: 'boolean', description: 'Include DOCTYPE declaration', required: false } }
 },
 evaluate_script: {
  name: 'evaluate_script',
  description: 'Execute JavaScript in page context and return serializable result',
  schema: { script: { type: 'string', description: 'JavaScript code to execute', required: true } }
 },
 press_key: {
  name: 'press_key',
  description: 'Press keyboard key on active page (e.g. Enter, Escape, Tab)',
  schema: { key: { type: 'string', description: 'Key name (e.g. Enter, Escape, ArrowDown)', required: true } }
 },
 handle_dialog: {
  name: 'handle_dialog',
  description: 'Handle browser dialog (alert/confirm/prompt). Call BEFORE the triggering action.',
  schema: {
   action: { type: 'string', enum: ['accept', 'dismiss'], description: 'How to handle dialog', required: true },
   promptText: { type: 'string', description: 'Text for prompt dialog', required: false }
  }
 },
 saveResult: {
  name: 'saveResult',
  description: 'Save intermediate/final result to file',
  schema: {
   filename: { type: 'string', description: 'Output filename (e.g. results.json)', required: true },
   content: { type: 'string', description: 'Content to save', required: true },
   append: { type: 'boolean', description: 'Append instead of overwrite', required: false }
  }
 },
 readResult: {
  name: 'readResult',
  description: 'Read previously saved result file (max 164k chars)',
  schema: { filename: { type: 'string', description: 'Filename to read', required: true } }
 },
 done: {
  name: 'done',
  description: 'Finish task and report final summary',
  schema: { reason: { type: 'string', description: 'Summary of accomplishments', required: true } }
 },
 generateFingerprint: {
  name: 'generateFingerprint',
  description: 'Generate and inject a new browser fingerprint',
  schema: { config: { type: 'object', description: 'Fingerprint generation config', required: false } }
 },
 detectStealthIssues: {
  name: 'detectStealthIssues',
  description: 'Detect potential stealth issues on current page',
  schema: {}
 },
 rotateBehaviorProfile: {
  name: 'rotateBehaviorProfile',
  description: 'Rotate the current behavior profile',
  schema: {}
 }
}

export { ToolsSchema }

===[END: {xd-chrome-tools-schema.js}]===

===[START: {xd-chrome-tools.js}]===
/**
 * @fileoverview Tool implementations for xd-chrome browser agent.
 * Each tool exposes `{ execute(ctx, params) }` bound to its schema.
 * @module xd-chrome-tools
 */

import { ToolsSchema } from './xd-chrome-tools-schema.js'
import { sleep } from './xd-chrome-helpers.js'
import { writeFile, mkdir } from 'fs/promises'
import { readFileSync, existsSync } from 'fs'
import { join } from 'path'

const MAX_CONTENT_LENGTH = 164000

/**
 * Create DOM snapshot by querying interactive elements.
 * @param {import('playwright').Page} page
 * @param {boolean} [verbose=false] - Include more elements
 * @returns {Promise<{elements: object[], text: string}>}
 */
const createSnapshot = async (page, verbose = false) => {
 const elements = await page.evaluate((wantVerbose) => {
  const selectors = [
   'a[href]', 'button', 'input', 'textarea', 'select',
   '[role="button"]', '[role="link"]', '[role="textbox"]'
  ]
  const esc = value => {
   if (window.CSS && typeof window.CSS.escape === 'function') return window.CSS.escape(value)
   return String(value).replace(/([^a-zA-Z0-9_-])/g, '\\$1')
  }
  const visible = el => {
   const r = el.getBoundingClientRect()
   if (r.width === 0 || r.height === 0) return false
   const s = window.getComputedStyle(el)
   return s.visibility !== 'hidden' && s.display !== 'none'
  }
  const nodes = Array.from(new Set(selectors.flatMap(sel => Array.from(document.querySelectorAll(sel))))).filter(visible).slice(0, wantVerbose ? 300 : 120)
  return nodes.map((el, idx) => {
   const role = el.getAttribute('role') || el.tagName.toLowerCase()
   const text = (el.getAttribute('aria-label') || el.innerText || el.textContent || '').replace(/\s+/g, ' ').trim().slice(0, 80)
   const id = el.id ? `#${esc(el.id)}` : ''
   const name = el.getAttribute('name') ? `[name="${String(el.getAttribute('name')).replace(/"/g, '\\"')}"]` : ''
   const selector = id || `${el.tagName.toLowerCase()}${name}`
   return { id: `el_${idx}`, selector, role, name: text, href: el.getAttribute('href') || null }
  })
 }, Boolean(verbose))
 const text = elements.map(el => `${el.id} [${el.role}] ${el.name || ''}`.trim()).join('\n')
 return { elements, text }
}

/**
 * Build tool registry from schema + function implementations.
 * @returns {Record<string, {name: string, description: string, schema: object, execute: Function}>}
 */
const createTools = () => {
 /** @type {Record<string, (ctx: object, params: object) => Promise<object>>} */
 const fnc = {
  /** Initialize browser if not already running. */
  init: async (ctx) => {
   if (!ctx.browser) await ctx.init()
   return { success: true, status: 'initialized' }
  },

  /** Close browser and cleanup. */
  close: async (ctx) => {
   await ctx.close()
   return { success: true, status: 'closed' }
  },

  /**
   * Navigate to URL with tunnel-fail retry and auto-snapshot.
   * @param {object} ctx @param {{url: string}} params
   */
  navigate: async (ctx, params) => {
   if (!ctx.page) await ctx.init()
   const targetUrl = params.url
   const timeout = ctx.config.browser.timeout || 30000

   const attemptGoto = () => ctx.page.goto(targetUrl, { waitUntil: 'domcontentloaded', timeout })

   try {
    await attemptGoto()
   } catch (navErr) {
    const msg = navErr?.message || ''
    if (msg.includes('ERR_TUNNEL_CONNECTION_FAILED') && ctx.rotateBrowser) {
     ctx.logger.warn('Tunnel failed, rotating proxy...')
     const rotated = await ctx.rotateBrowser()
     if (rotated) await attemptGoto()
     else throw navErr
    } else { throw navErr }
   }

   await sleep(500)
   ctx.currentUrl = ctx.page.url()
   ctx.addVisitedUrl(ctx.currentUrl)
   if (ctx._proxyManager && ctx._proxyLaunchRaw) ctx._proxyManager.reportSuccess(ctx._proxyLaunchRaw)

   // Auto-snapshot after navigation
   const snap = await createSnapshot(ctx.page, false)
   ctx.lastSnapshot = snap
   return { success: true, url: ctx.currentUrl, snapshot: snap.text, elementCount: snap.elements.length }
  },

  /** Take DOM snapshot of interactive elements. */
  snapshot: async (ctx, params) => {
   const snap = await createSnapshot(ctx.page, params?.verbose)
   ctx.lastSnapshot = snap
   return { success: true, elementCount: snap.elements.length, snapshot: snap.text }
  },

  /**
   * Click element with multi-strategy fallback (selector → role → text → JS click).
   * @param {object} ctx @param {{uid: string}} params
   */
  click: async (ctx, params) => {
   const item = ctx.lastSnapshot?.elements?.find(el => el.id === params.uid)
   if (!item) throw new Error(`Element not found in snapshot: ${params.uid}`)

   const urlBefore = ctx.page.url()
   const tabsBefore = ctx.pages.length

   // Try primary selector
   let clicked = false
   const locator = ctx.page.locator(item.selector).first()
   try {
    await locator.scrollIntoViewIfNeeded({ timeout: 2000 }).catch(() => {})
    await locator.click({ timeout: 5000, force: true })
    clicked = true
   } catch {
    // Fallback: role+name
    if (item.role && item.name) {
     try {
      await ctx.page.getByRole(item.role, { name: item.name, exact: false }).first().click({ timeout: 3000, force: true })
      clicked = true
     } catch {}
    }
    // Fallback: text match
    if (!clicked && item.name) {
     try {
      await ctx.page.getByText(item.name, { exact: false }).first().click({ timeout: 3000, force: true })
      clicked = true
     } catch {}
    }
    // Fallback: JS click
    if (!clicked) {
     try {
      await locator.evaluate(el => el.click())
      clicked = true
     } catch (err) { throw new Error(`All click strategies failed for ${params.uid}: ${err.message}`) }
    }
   }

   await sleep(500)
   // Handle new tab auto-switch
   const tabsAfter = ctx.pages.length
   const newTabOpened = tabsAfter > tabsBefore
   if (newTabOpened) {
    await ctx.switchToTab(tabsAfter - 1)
   }

   ctx.currentUrl = ctx.page.url()
   ctx.addVisitedUrl(ctx.currentUrl)

   // If URL didn't change and element is a link, fallback to direct navigation
   if (ctx.currentUrl === urlBefore && item.role === 'link' && item.href) {
    try {
     const resolved = new URL(item.href, ctx.page.url()).toString()
     await ctx.page.goto(resolved, { waitUntil: 'domcontentloaded', timeout: ctx.config.browser.timeout || 30000 })
     await sleep(400)
     ctx.currentUrl = ctx.page.url()
     ctx.addVisitedUrl(ctx.currentUrl)
    } catch {}
   }

   ctx.lastSnapshot = null
   return { success: true, clicked: params.uid, newTabOpened, url: ctx.currentUrl }
  },

  /**
   * Fill input with optional stealth typing emulation.
   * @param {object} ctx @param {{uid: string, text: string}} params
   */
  fill: async (ctx, params) => {
   const item = ctx.lastSnapshot?.elements?.find(el => el.id === params.uid)
   if (!item) throw new Error(`Element not found in snapshot: ${params.uid}`)
   if (ctx.stealthSession?.emulateTyping) {
    await ctx.stealthSession.emulateTyping(item.selector, params.text)
   } else {
    const locator = item.selector
     ? ctx.page.locator(item.selector).first()
     : ctx.page.getByRole('textbox', { name: item.name }).first()
    await locator.fill(params.text, { timeout: 5000 })
   }
   return { success: true, uid: params.uid, textLength: String(params.text || '').length }
  },

  /** Open link by resolving href and navigating directly. */
  openLink: async (ctx, params) => {
   const item = ctx.lastSnapshot?.elements?.find(el => el.id === params.uid)
   if (!item) throw new Error(`Element not found in snapshot: ${params.uid}`)
   let href = item.href
   if (!href) {
    // Attempt to find href in DOM
    href = await ctx.page.evaluate(sel => {
     try { const el = document.querySelector(sel); return el?.href || el?.getAttribute('href') || null } catch { return null }
    }, item.selector)
   }
   if (!href) throw new Error(`Element has no href: ${params.uid}`)
   if (href.startsWith('javascript:')) throw new Error('Cannot navigate to javascript: href')
   const resolved = new URL(href, ctx.page.url()).toString()
   await ctx.page.goto(resolved, { waitUntil: 'domcontentloaded', timeout: ctx.config.browser.timeout || 30000 })
   await sleep(400)
   ctx.currentUrl = ctx.page.url()
   ctx.addVisitedUrl(ctx.currentUrl)
   return { success: true, url: ctx.currentUrl }
  },

  /** Scroll page with optional stealth emulation. */
  scroll: async (ctx, params = {}) => {
   const direction = params.direction || 'down'
   const distance = params.distance || 500
   if (direction === 'bottom') {
    await ctx.page.evaluate(() => window.scrollTo(0, document.body.scrollHeight))
   } else if (ctx.stealthSession?.emulateScroll) {
    await ctx.stealthSession.emulateScroll(distance, direction)
   } else {
    await ctx.page.mouse.wheel(0, direction === 'up' ? -distance : distance)
   }
   await sleep(300)
   ctx.lastSnapshot = null
   return { success: true, direction }
  },

  /** Switch to tab by index or URL fragment. */
  switchToTab: async (ctx, params) => {
   const value = String(params.target || '')
   const index = Number.parseInt(value, 10)
   const ok = Number.isNaN(index) ? await ctx.switchToTab(value) : await ctx.switchToTab(index)
   if (!ok) {
    const tabInfo = ctx.pages.map((p, i) => { try { return `${i}: ${p.url()}` } catch { return `${i}: unknown` } })
    throw new Error(`Tab not found: ${params.target}. Available:\n${tabInfo.join('\n')}`)
   }
   return { success: true, index: ctx.currentPageIndex, url: ctx.currentUrl, totalTabs: ctx.pages.length }
  },

  /** Check proxy status or rotate proxy/browser session. */
  proxyControl: async (ctx, params) => {
   const action = params.action
   if (action === 'status') {
    return { success: true, enabled: !!ctx._proxyManager, stats: ctx._proxyManager?.getStats?.() || { total: 0, available: 0, banned: 0 } }
   }
   if (action === 'rotate') {
    if (!ctx._proxyManager) throw new Error('Proxy manager unavailable')
    if (params.reason) ctx.logger.info(`Proxy rotate: ${params.reason}`)
    const rotated = await ctx.rotateBrowser()
    if (!rotated) throw new Error('Proxy rotation failed')
    return { success: true, rotated: true, url: ctx.currentUrl, stats: ctx._proxyManager.getStats() }
   }
   throw new Error(`Unknown proxy action: ${action}`)
  },

  /** Adblock control: status/enable/disable/setMode/updateConfig/resetStats. */
  adblockControl: async (ctx, params) => {
   const action = params.action
   if (!ctx.adblock || typeof ctx.adblock.getStatus !== 'function') throw new Error('Adblock not initialized')
   if (action === 'status') return { success: true, ...ctx.adblock.getStatus() }
   if (action === 'enable') return { success: true, ...(await ctx.adblock.setEnabled(true)) }
   if (action === 'disable') return { success: true, ...(await ctx.adblock.setEnabled(false)) }
   if (action === 'setMode') return { success: true, ...(await ctx.adblock.setMode(params.mode || 'balanced')) }
   if (action === 'updateConfig') return { success: true, ...(await ctx.adblock.updateConfig(params.patch || {})) }
   if (action === 'resetStats') return { success: true, ...ctx.adblock.resetStats() }
   throw new Error(`Unknown adblock action: ${action}`)
  },

  /** Wait for given milliseconds. */
  wait: async (_ctx, params) => {
   await sleep(params.ms)
   return { success: true, waited: params.ms }
  },

  /**
   * Extract readable text content from page, stripping nav/footer/scripts.
   * @param {object} ctx @param {{selector?: string}} params
   */
  extractContent: async (ctx, params) => {
   const selector = (typeof params?.selector === 'string' && params.selector.trim()) || 'body'
   const content = await ctx.page.evaluate(sel => {
    const target = document.querySelector(sel) || document.body
    const clone = target.cloneNode(true)
    for (const tag of ['script', 'style', 'nav', 'header', 'footer', 'aside', 'noscript']) {
     clone.querySelectorAll(tag).forEach(el => el.remove())
    }
    const getText = node => {
     if (node.nodeType === Node.TEXT_NODE) return node.textContent.trim()
     if (node.nodeType === Node.ELEMENT_NODE) return Array.from(node.childNodes).map(getText).filter(Boolean).join(' ')
     return ''
    }
    return getText(clone).replace(/\s+/g, ' ').trim()
   }, selector)
   const truncated = content.length > MAX_CONTENT_LENGTH
   return { success: true, content: truncated ? content.substring(0, MAX_CONTENT_LENGTH) + '\n... (truncated)' : content, length: content.length, truncated }
  },

  /** Get raw HTML source of current page. */
  getSource: async (ctx, params) => {
   const rawHtml = await ctx.page.content()
   const html = params?.includeDoctype !== false ? `<!DOCTYPE html>\n${rawHtml}` : rawHtml
   const truncated = html.length > MAX_CONTENT_LENGTH
   return { success: true, url: ctx.page.url(), source: truncated ? html.substring(0, MAX_CONTENT_LENGTH) + '\n<!-- truncated -->' : html, length: html.length, truncated }
  },

  /** Execute arbitrary JS in page context. */
  evaluate_script: async (ctx, params) => {
   const script = String(params.script || '').trim()
   if (!script) throw new Error('script is required')
   const result = await ctx.page.evaluate(async ({ userScript }) => {
    const fn = new Function(`return (async () => { ${userScript} })();`)
    return await fn()
   }, { userScript: script })
   const serialized = typeof result === 'string' ? result : JSON.stringify(result)
   return { success: true, result, preview: (serialized || String(result)).slice(0, 2000) }
  },

  /** Press keyboard key. */
  press_key: async (ctx, params) => {
   const key = String(params.key || '').trim()
   if (!key) throw new Error('key is required')
   await ctx.page.keyboard.press(key)
   await sleep(200)
   ctx.currentUrl = ctx.page.url()
   ctx.addVisitedUrl(ctx.currentUrl)
   return { success: true, key }
  },

  /** Handle browser dialog (alert/confirm/prompt). */
  handle_dialog: async (ctx, params) => {
   const action = String(params.action || '').toLowerCase()
   if (!['accept', 'dismiss'].includes(action)) throw new Error('action must be accept or dismiss')
   return new Promise(resolve => {
    const timer = setTimeout(() => {
     ctx.page.removeListener('dialog', onDialog)
     resolve({ success: false, handled: false, reason: 'No dialog within timeout' })
    }, 2000)
    const onDialog = async dialog => {
     clearTimeout(timer)
     try {
      if (action === 'accept') await dialog.accept(String(params.promptText ?? ''))
      else await dialog.dismiss()
      resolve({ success: true, handled: true, dialogType: dialog.type(), message: dialog.message(), action })
     } catch (err) { resolve({ success: false, handled: false, error: err.message }) }
    }
    ctx.page.once('dialog', onDialog)
   })
  },

  /** Save content to results directory. */
  saveResult: async (ctx, params) => {
   const resultsDir = join(process.cwd(), 'results')
   await mkdir(resultsDir, { recursive: true })
   const safeName = (params.filename || 'result.md').replace(/[^a-zA-Z0-9_.\-]/g, '_').slice(0, 100)
   const filepath = join(resultsDir, safeName)
   const body = params.content || ''
   if (params.append && existsSync(filepath)) {
    const existing = readFileSync(filepath, 'utf-8')
    await writeFile(filepath, `${existing}\n\n---\n\n${body}`, 'utf-8')
   } else {
    await writeFile(filepath, body, 'utf-8')
   }
   return { success: true, filepath: `results/${safeName}`, length: body.length, appended: !!params.append }
  },

  /** Read previously saved result file. */
  readResult: async (_ctx, params) => {
   const safeName = (params.filename || '').replace(/[^a-zA-Z0-9_.\-]/g, '_').slice(0, 100)
   const filepath = join(process.cwd(), 'results', safeName)
   if (!existsSync(filepath)) throw new Error(`File not found: ${safeName}`)
   const content = readFileSync(filepath, 'utf-8')
   const truncated = content.length > MAX_CONTENT_LENGTH
   return { success: true, filename: safeName, content: truncated ? content.substring(0, MAX_CONTENT_LENGTH) + '\n... (truncated)' : content, length: content.length, truncated }
  },

  /** Signal task completion. */
  done: async (_ctx, params) => {
   return { done: true, reason: params.reason }
  },

  /** Generate and inject browser fingerprint. */
  generateFingerprint: async (ctx, params) => {
   const fingerprint = ctx.fingerprintManager.generate(params.config || {})
   if (ctx.page) await ctx.fingerprintManager.injectIntoPage(ctx.page, fingerprint)
   return { success: true, hash: fingerprint.hash, userAgent: fingerprint.userAgent, platform: fingerprint.platform }
  },

  /** Detect stealth issues (webdriver, plugins, etc). */
  detectStealthIssues: async (ctx) => {
   if (!ctx.page) return { success: false, error: 'No page available' }
   const issues = []
   try {
    const props = await ctx.page.evaluate(() => ({
     webdriver: navigator.webdriver, plugins: navigator.plugins.length,
     languages: navigator.languages, platform: navigator.platform
    }))
    if (props.webdriver !== false && props.webdriver !== undefined) issues.push({ type: 'webdriver', severity: 'high', message: 'Webdriver property detected' })
    if (props.plugins < 3) issues.push({ type: 'plugins', severity: 'medium', message: `Low plugin count: ${props.plugins}` })
   } catch (err) { issues.push({ type: 'evaluation', severity: 'high', message: err.message }) }
   return { success: true, issues, timestamp: new Date().toISOString() }
  },

  /** Rotate behavior profile for stealth. */
  rotateBehaviorProfile: async (ctx) => {
   const profile = ctx.behaviorEmulator.rotateProfile()
   return { success: true, profile, metrics: ctx.behaviorEmulator.getBehaviorMetrics() }
  }
 }

 /** @type {Record<string, object>} */
 const registry = {}
 for (const [name, schema] of Object.entries(ToolsSchema)) {
  if (fnc[name]) registry[name] = { ...schema, execute: fnc[name] }
 }
 return registry
}

export { createTools, createSnapshot }

===[END: {xd-chrome-tools.js}]===

===[START: {xd-chrome.js}]===
#!/usr/bin/env node
/**
 * @fileoverview xd-chrome entry point. Runs CLI with process argv.
 * @module xd-chrome
 */

import { runCli } from './xd-chrome-cli.js'

/** Launch CLI, exit with returned code. */
const main = async () => {
 const code = await runCli(process.argv.slice(2))
 process.exit(code)
}

if (import.meta.url === `file://${process.argv[1]}`) {
 main().catch(error => {
  console.error(error?.stack || error?.message || String(error))
  process.exit(1)
 })
}

export { main }

===[END: {xd-chrome.js}]===

